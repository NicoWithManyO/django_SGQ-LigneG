/**
 * Fonctions de debug pour Production V2
 */

// ===== FONCTIONS DE DEBUG =====
window.logDebug = function(message, type = 'info') {
    const log = document.getElementById('debug-log');
    if (!log) return;
    
    const time = new Date().toLocaleTimeString();
    const colors = {
        info: '#90caf9',
        success: '#81c784',
        error: '#ef5350',
        warning: '#ffb74d'
    };
    
    const entry = document.createElement('div');
    entry.style.color = colors[type] || colors.info;
    entry.innerHTML = `[${time}] ${message}`;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
    
    // Log aussi dans la console
    console.log(`[${type.toUpperCase()}] ${message}`);
};

window.clearDebug = function() {
    const log = document.getElementById('debug-log');
    if (log) {
        log.innerHTML = '<div style="color: var(--v2-success-light);">Debug console cleared...</div>';
    }
};

window.toggleDebugPanel = function() {
    const panel = document.getElementById('debug-panel');
    if (!panel) return;
    
    if (panel.style.height === '40px') {
        panel.style.height = 'auto';
    } else {
        panel.style.height = '40px';
    }
};

window.toggleDebugConsole = function() {
    const panel = document.getElementById('debug-panel');
    if (panel) {
        panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }
};

// ===== TESTS API =====
window.testSession = async function() {
    logDebug('Test Session API...', 'info');
    
    try {
        const response = await fetch('/api/session/', {
            headers: {
                'X-CSRFToken': getCsrfToken()
            }
        });
        
        if (response.ok) {
            const data = await response.json();
            logDebug('‚úÖ Session API: OK', 'success');
            
            // Test des donn√©es principales
            const tests = [
                { key: 'operator_id', label: 'Op√©rateur' },
                { key: 'shift_id', label: 'ID Poste' },
                { key: 'shift_form_shift_date', label: 'Date poste' },
                { key: 'shift_form_vacation', label: 'Vacation' },
                { key: 'of_en_cours', label: 'OF en cours' },
                { key: 'target_length', label: 'Longueur cible' },
                { key: 'profile_id', label: 'Profil' }
            ];
            
            tests.forEach(test => {
                if (data[test.key]) {
                    logDebug(`‚úÖ ${test.label}: ${data[test.key]}`, 'success');
                } else {
                    logDebug(`‚ö†Ô∏è ${test.label}: non d√©fini`, 'warning');
                }
            });
            
            // Test des donn√©es rouleau
            if (data.roll_measurements && Object.keys(data.roll_measurements).length > 0) {
                logDebug(`‚úÖ Mesures d'√©paisseur: ${Object.keys(data.roll_measurements).length} enregistr√©es`, 'success');
            } else {
                logDebug('‚ö†Ô∏è Mesures d\'√©paisseur: aucune', 'warning');
            }
            
            if (data.roll_defects && Object.keys(data.roll_defects).length > 0) {
                logDebug(`‚úÖ D√©fauts: ${Object.keys(data.roll_defects).length} positions avec d√©fauts`, 'success');
            } else {
                logDebug('‚ö†Ô∏è D√©fauts: aucun', 'warning');
            }
            
            // Afficher un r√©sum√© complet
            logDebug('--- R√©sum√© complet ---', 'info');
            console.log('Session compl√®te:', data);
        } else {
            logDebug(`‚ùå Session API: ${response.status}`, 'error');
        }
    } catch (error) {
        logDebug('‚ùå Erreur r√©seau: ' + error.message, 'error');
    }
};

window.testConnection = async function() {
    logDebug('Test de connexion et synchronisation...', 'info');
    
    // Test 1: V√©rifier les modules core
    logDebug('--- Test des modules Core V2 ---', 'info');
    const modules = [
        { name: 'StateManager', obj: window.stateManager },
        { name: 'CommandBus', obj: window.commandBus },
        { name: 'SyncEngine', obj: window.syncEngine },
        { name: 'EventBus', obj: window.eventBus },
        { name: 'API V2', obj: window.api }
    ];
    
    let coreOk = true;
    modules.forEach(module => {
        if (module.obj) {
            logDebug(`‚úÖ ${module.name} charg√©`, 'success');
        } else {
            logDebug(`‚ùå ${module.name} manquant`, 'error');
            coreOk = false;
        }
    });
    
    // Test 2: √âtat de synchronisation
    if (window.syncEngine) {
        logDebug('--- √âtat de synchronisation ---', 'info');
        const syncState = window.syncEngine.getSyncState();
        
        if (syncState.pending > 0) {
            logDebug(`‚è≥ ${syncState.pending} √©l√©ments en attente de sync`, 'warning');
        } else {
            logDebug('‚úÖ Aucune sync en attente', 'success');
        }
        
        if (syncState.failed > 0) {
            logDebug(`‚ùå ${syncState.failed} syncs √©chou√©es`, 'error');
            if (syncState.lastError) {
                logDebug(`  ‚Üí Derni√®re erreur: ${syncState.lastError}`, 'error');
            }
        }
        
        if (syncState.lastSyncTime) {
            const ago = Math.round((Date.now() - syncState.lastSyncTime) / 1000);
            logDebug(`‚è∞ Derni√®re sync il y a ${ago}s`, 'info');
        }
    }
    
    // Test 3: Endpoints API
    logDebug('--- Test des endpoints API ---', 'info');
    const endpoints = [
        { url: '/api/session/', name: 'Session', critical: true },
        { url: '/api/operators/', name: 'Op√©rateurs', critical: true },
        { url: '/api/fabrication-orders/', name: 'Ordres de Fabrication', critical: true },
        { url: '/api/profiles/', name: 'Profils', critical: true },
        { url: '/api/defect-types/', name: 'Types d√©fauts', critical: true },
        { url: '/api/shifts/', name: 'Postes', critical: false },
        { url: '/api/rolls/', name: 'Rouleaux', critical: false }
    ];
    
    let criticalOk = true;
    let allOk = true;
    
    for (const endpoint of endpoints) {
        try {
            const startTime = Date.now();
            const response = await fetch(endpoint.url, {
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });
            const responseTime = Date.now() - startTime;
            
            if (response.ok) {
                logDebug(`‚úÖ ${endpoint.name} (${responseTime}ms)`, 'success');
            } else {
                logDebug(`‚ùå ${endpoint.name}: HTTP ${response.status}`, 'error');
                allOk = false;
                if (endpoint.critical) criticalOk = false;
            }
        } catch (error) {
            logDebug(`‚ùå ${endpoint.name}: ${error.message}`, 'error');
            allOk = false;
            if (endpoint.critical) criticalOk = false;
        }
    }
    
    // Test 4: Test de sauvegarde
    if (criticalOk && window.api) {
        logDebug('--- Test de sauvegarde ---', 'info');
        try {
            const testData = { test_timestamp: Date.now() };
            await window.api.saveToSession(testData);
            logDebug('‚úÖ Test de sauvegarde r√©ussi', 'success');
        } catch (error) {
            logDebug('‚ùå √âchec du test de sauvegarde', 'error');
        }
    }
    
    // R√©sum√© final
    logDebug('--- R√©sum√© ---', 'info');
    if (coreOk && criticalOk) {
        logDebug('‚úÖ Syst√®me op√©rationnel', 'success');
        updateSyncStatus('connected');
    } else if (coreOk && !criticalOk) {
        logDebug('‚ö†Ô∏è Probl√®me de connexion API', 'warning');
        updateSyncStatus('error');
    } else {
        logDebug('‚ùå Syst√®me non initialis√©', 'error');
        updateSyncStatus('disconnected');
    }
};

window.testStateManager = function() {
    logDebug('Test StateManager & Core V2', 'info');
    
    // Test StateManager
    if (!window.stateManager) {
        logDebug('‚ùå StateManager non trouv√©!', 'error');
        return;
    }
    logDebug('‚úÖ StateManager disponible', 'success');
    
    // Test CommandBus
    if (!window.commandBus) {
        logDebug('‚ùå CommandBus non trouv√©!', 'error');
    } else {
        logDebug('‚úÖ CommandBus disponible', 'success');
        const commands = window.commandBus.getCommands();
        logDebug(`üìù ${commands.length} commandes enregistr√©es`, 'info');
        console.log('Commandes disponibles:', commands);
    }
    
    // Test SyncEngine
    if (!window.syncEngine) {
        logDebug('‚ùå SyncEngine non trouv√©!', 'error');
    } else {
        logDebug('‚úÖ SyncEngine disponible', 'success');
        const syncState = window.syncEngine.getSyncState();
        logDebug(`üìä Sync: ${syncState.pending} en attente, ${syncState.failed} √©chou√©s`, 'info');
    }
    
    // Test EventBus
    if (!window.eventBus) {
        logDebug('‚ùå EventBus non trouv√©!', 'error');
    } else {
        logDebug('‚úÖ EventBus disponible', 'success');
    }
    
    // Test ValidationEngine
    if (!window.validationEngine) {
        logDebug('‚ùå ValidationEngine non trouv√©!', 'error');
    } else {
        logDebug('‚úÖ ValidationEngine disponible', 'success');
    }
    
    // Test API V2
    if (!window.api || !window.apiV2) {
        logDebug('‚ùå API V2 non trouv√©e!', 'error');
    } else {
        logDebug('‚úÖ API V2 disponible', 'success');
    }
    
    // Afficher l'√©tat actuel
    const state = window.stateManager.getState();
    logDebug('--- √âtat actuel ---', 'info');
    
    // Afficher les namespaces avec plus de d√©tails
    const namespaces = {
        'shift': 'Donn√©es du poste',
        'of': 'Ordres de fabrication',
        'roll': 'Donn√©es rouleau',
        'profile': 'Profil s√©lectionn√©',
        'qc': 'Contr√¥le qualit√©',
        'production': 'Production'
    };
    
    Object.entries(namespaces).forEach(([key, label]) => {
        const value = state[key];
        if (value && typeof value === 'object') {
            const count = Object.keys(value).length;
            if (count > 0) {
                logDebug(`‚úÖ ${label}: ${count} propri√©t√©s`, 'success');
                // Afficher quelques valeurs cl√©s
                if (key === 'shift' && value.operatorId) {
                    logDebug(`  ‚Üí Op√©rateur: ${value.operatorId}`, 'info');
                }
                if (key === 'of' && value.targetLength) {
                    logDebug(`  ‚Üí Longueur cible: ${value.targetLength}m`, 'info');
                }
                if (key === 'roll' && value.measurements) {
                    const measureCount = Object.keys(value.measurements || {}).length;
                    logDebug(`  ‚Üí ${measureCount} mesures d'√©paisseur`, 'info');
                }
            } else {
                logDebug(`‚ö†Ô∏è ${label}: vide`, 'warning');
            }
        } else {
            logDebug(`‚ö†Ô∏è ${label}: non initialis√©`, 'warning');
        }
    });
    
    // Test de lecture/√©criture
    logDebug('--- Test lecture/√©criture ---', 'info');
    const testValue = Date.now();
    window.stateManager.setState('test.debug', testValue, 'system');
    const readValue = window.stateManager.getState('test.debug');
    if (readValue === testValue) {
        logDebug('‚úÖ Test lecture/√©criture r√©ussi', 'success');
    } else {
        logDebug('‚ùå √âchec du test lecture/√©criture', 'error');
    }
    
    console.log('√âtat complet:', state);
};

window.clearSession = async function() {
    if (!confirm('‚ö†Ô∏è √ätes-vous s√ªr de vouloir vider toute la session ?')) {
        return;
    }
    
    logDebug('Suppression de la session...', 'warning');
    
    try {
        // Utiliser PATCH pour vider la session
        const response = await fetch('/api/session/', {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCsrfToken()
            },
            body: JSON.stringify({
                profile_id: null,
                shift_id: null,
                operator_id: null,
                shift_date: null,
                vacation: null,
                start_time: null,
                end_time: null,
                machine_started_start: null,
                machine_started_end: null,
                length_start: null,
                length_end: null,
                comment: null,
                of_en_cours: null,
                target_length: null,
                of_decoupe: null,
                roll_number: null,
                quality_control: null,
                checklist_responses: null,
                wound_length_ok: 0,
                wound_length_nok: 0,
                wound_length_total: 0
            })
        });
        
        if (response.ok) {
            logDebug('‚úÖ Session vid√©e avec succ√®s!', 'success');
            
            // Recharger la page apr√®s 1 seconde
            setTimeout(() => {
                logDebug('Rechargement de la page...', 'info');
                window.location.reload();
            }, 1000);
        } else {
            logDebug(`‚ùå Erreur suppression session: ${response.status} ${response.statusText}`, 'error');
        }
    } catch (error) {
        logDebug('‚ùå Erreur r√©seau: ' + error.message, 'error');
    }
};

// Helper
function getCsrfToken() {
    const cookie = document.cookie.split('; ').find(row => row.startsWith('csrftoken='));
    return cookie ? cookie.split('=')[1] : window.CSRF_TOKEN || '';
}